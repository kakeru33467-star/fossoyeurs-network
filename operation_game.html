<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Simulation – Arène</title>
<style>
body{
    margin:0;
    background:linear-gradient(#87c9ff,#e6f4ff);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    height:100vh;
    font-family:monospace;
}

canvas{
    border:4px solid #2c5f85;
    background:#a8ddff;
}

.controls{
    margin-top:10px;
    font-size:14px;
    color:#333;
}
</style>
</head>
<body>

<canvas id="arena" width="900" height="500"></canvas>

<div class="controls">
Déplacement : Q / D — Saut : Z — Attaque : E
</div>

<audio id="music" src="audio/combat.mp3" loop></audio>

<script>

const canvas = document.getElementById("arena");
const ctx = canvas.getContext("2d");
const music = document.getElementById("music");

document.addEventListener("click",()=>{
    music.volume = 0.4;
    music.play().catch(()=>{});
},{once:true});

const GRAVITY = 2000;
const FLOOR = 460;

let playerScore = 0;
let enemyScore = 0;

const platforms = [
    {x:200,y:420,w:120,h:15},
    {x:400,y:360,w:150,h:15},
    {x:650,y:300,w:120,h:15},
    {x:100,y:300,w:120,h:15}
];

class Fighter{
    constructor(x,color,isAI=false){
        this.startX = x;
        this.x = x;
        this.y = FLOOR;
        this.vx = 0;
        this.vy = 0;
        this.width = 40;
        this.height = 40;
        this.color = color;
        this.health = 100;
        this.isAI = isAI;
        this.direction = 1;
        this.onGround = false;
        this.attacking = false;
        this.attackTime = 0;
        this.cooldown = 0;
    }

    reset(){
        this.x = this.startX;
        this.y = FLOOR;
        this.vx = 0;
        this.vy = 0;
        this.health = 100;
        this.attacking = false;
    }

    update(dt, opponent){

        this.direction = this.x < opponent.x ? 1 : -1;

        this.vy += GRAVITY * dt;
        this.y += this.vy * dt;

        if(this.y > FLOOR){
            this.y = FLOOR;
            this.vy = 0;
            this.onGround = true;
        }

        platforms.forEach(p=>{
            if(this.x+this.width > p.x &&
               this.x < p.x+p.w &&
               this.y >= p.y &&
               this.y <= p.y+20 &&
               this.vy >= 0){
                   this.y = p.y;
                   this.vy = 0;
                   this.onGround = true;
            }
        });

        this.x += this.vx * dt;

        if(this.x < 0) this.x = 0;
        if(this.x > canvas.width - this.width) this.x = canvas.width - this.width;

        if(this.cooldown > 0) this.cooldown -= dt;

        if(this.attacking){
            this.attackTime -= dt;
            if(this.attackTime <= 0){
                this.attacking = false;
            }
        }
    }

    move(dir){
        this.vx = dir * 300;
    }

    stop(){
        this.vx = 0;
    }

    jump(){
        if(this.onGround){
            this.vy = -850;
            this.onGround = false;
        }
    }

    attack(){
        if(this.cooldown <= 0){
            this.attacking = true;
            this.attackTime = 0.25;
            this.cooldown = 0.6;
        }
    }

    draw(){

        // corps
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y-this.height, this.width, this.height);

        // visage
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x+10, this.y-30, 5,5);
        ctx.fillRect(this.x+25, this.y-30, 5,5);
        ctx.fillRect(this.x+15, this.y-15, 10,3);

        // épée
        ctx.strokeStyle="#ccc";
        ctx.lineWidth=4;

        if(!this.attacking){
            ctx.beginPath();
            ctx.moveTo(this.x+20,this.y-this.height-15);
            ctx.lineTo(this.x+20,this.y-this.height+10);
            ctx.stroke();
        }else{
            // mouvement haut -> bas
            const progress = 1 - (this.attackTime/0.25);
            ctx.beginPath();
            ctx.moveTo(this.x+20,this.y-this.height-15);
            ctx.lineTo(this.x+20,
                       this.y-this.height-15 + 40*progress);
            ctx.stroke();
        }
    }

    getAttackBox(){
        if(!this.attacking) return null;

        return {
            x: this.direction === 1 ? this.x+this.width : this.x-30,
            y: this.y-40,
            w: 30,
            h: 40
        };
    }

    getBody(){
        return {
            x:this.x,
            y:this.y-this.height,
            w:this.width,
            h:this.height
        };
    }
}

const player = new Fighter(150,"#ffffff");
const enemy = new Fighter(700,"#ff4d4d",true);

let keys = {};
let lastTime = 0;

document.addEventListener("keydown",e=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === "e") player.attack();
});

document.addEventListener("keyup",e=>{
    keys[e.key.toLowerCase()] = false;
});

function rect(a,b){
    return a.x < b.x+b.w &&
           a.x+a.w > b.x &&
           a.y < b.y+b.h &&
           a.y+a.h > b.y;
}

function handleInput(){
    player.stop();
    if(keys["q"]) player.move(-1);
    if(keys["d"]) player.move(1);
    if(keys["z"]) player.jump();
}

function enemyAI(){
    const dist = enemy.x - player.x;

    if(Math.abs(dist) > 80){
        enemy.move(dist > 0 ? -1 : 1);
    }else{
        enemy.stop();
        if(Math.random() < 0.02){
            enemy.attack();
        }
    }
}

function combat(){

    const pBox = player.getAttackBox();
    const eBody = enemy.getBody();

    if(pBox && rect(pBox,eBody)){
        enemy.health -= 10;
    }

    const eBox = enemy.getAttackBox();
    const pBody = player.getBody();

    if(eBox && rect(eBox,pBody)){
        player.health -= 5;
    }

    if(enemy.health <= 0){
        playerScore++;
        nextRound();
    }

    if(player.health <= 0){
        enemyScore++;
        nextRound();
    }
}

function nextRound(){
    if(playerScore === 3){
        alert("Victoire !");
        window.location.href="dashboard.html";
        return;
    }
    if(enemyScore === 3){
        alert("Défaite...");
        window.location.href="dashboard.html";
        return;
    }
    player.reset();
    enemy.reset();
}

function drawArena(){

    // ciel
    ctx.fillStyle="#87c9ff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // sol
    ctx.fillStyle="#6bbf59";
    ctx.fillRect(0,FLOOR,canvas.width,40);

    // plateformes
    ctx.fillStyle="#8d6e63";
    platforms.forEach(p=>{
        ctx.fillRect(p.x,p.y,p.w,p.h);
    });

    // barres de vie
    ctx.fillStyle="#000";
    ctx.fillRect(50,30,300,20);
    ctx.fillRect(550,30,300,20);

    ctx.fillStyle="#4caf50";
    ctx.fillRect(50,30,300*(player.health/100),20);
    ctx.fillRect(550,30,300*(enemy.health/100),20);

    // score
    ctx.fillStyle="#000";
    ctx.font="20px monospace";
    ctx.fillText(playerScore + " - " + enemyScore,420,45);
}

function loop(timestamp){

    const dt = (timestamp - lastTime)/1000;
    lastTime = timestamp;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawArena();

    handleInput();
    enemyAI();

    player.update(dt,enemy);
    enemy.update(dt,player);

    combat();

    player.draw();
    enemy.draw();

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>
