<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Simulation – Arène</title>

<style>
body{
    margin:0;
    background:linear-gradient(#87c9ff,#e6f4ff);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    height:100vh;
    font-family:monospace;
}

canvas{
    border:4px solid #2c5f85;
    background:#a8ddff;
}

.controls{
    margin-top:10px;
    font-size:14px;
    color:#333;
}
</style>
</head>

<body>

<canvas id="arena" width="900" height="500"></canvas>

<div class="controls">
Déplacement : Q / D — Saut : Z — Attaque : E
</div>

<audio id="music" src="audio/combat.mp3" loop></audio>

<script>

const canvas = document.getElementById("arena");
const ctx = canvas.getContext("2d");
const music = document.getElementById("music");

document.addEventListener("click",()=>{
    music.volume = 0.4;
    music.play().catch(()=>{});
},{once:true});

const GRAVITY = 2000;
const FLOOR = 460;

let playerScore = 0;
let enemyScore = 0;

const platforms = [
    {x:200,y:420,w:120,h:15},
    {x:400,y:360,w:150,h:15},
    {x:650,y:300,w:120,h:15},
    {x:100,y:300,w:120,h:15}
];

class Fighter{
    constructor(x,color,isAI=false){
        this.startX = x;
        this.x = x;
        this.y = FLOOR;
        this.vx = 0;
        this.vy = 0;
        this.width = 45;
        this.height = 60;
        this.color = color;

        this.maxHealth = 150;
        this.health = this.maxHealth;

        this.isAI = isAI;
        this.direction = 1;
        this.onGround = false;

        this.attacking = false;
        this.attackTime = 0;
        this.cooldown = 0;

        this.knockback = 0;
    }

    reset(){
        this.x = this.startX;
        this.y = FLOOR;
        this.vx = 0;
        this.vy = 0;
        this.health = this.maxHealth;
        this.attacking = false;
        this.knockback = 0;
    }

    update(dt, opponent){

        this.direction = this.x < opponent.x ? 1 : -1;

        this.vy += GRAVITY * dt;
        this.y += this.vy * dt;

        if(this.y > FLOOR){
            this.y = FLOOR;
            this.vy = 0;
            this.onGround = true;
        }

        platforms.forEach(p=>{
            if(this.x+this.width > p.x &&
               this.x < p.x+p.w &&
               this.y >= p.y &&
               this.y <= p.y+20 &&
               this.vy >= 0){
                   this.y = p.y;
                   this.vy = 0;
                   this.onGround = true;
            }
        });

        this.x += this.vx * dt;
        this.x += this.knockback;
        this.knockback *= 0.8;

        if(this.x < 0) this.x = 0;
        if(this.x > canvas.width - this.width) this.x = canvas.width - this.width;

        if(this.cooldown > 0) this.cooldown -= dt;

        if(this.attacking){
            this.attackTime -= dt;
            if(this.attackTime <= 0){
                this.attacking = false;
            }
        }
    }

    move(dir){
        this.vx = dir * 320;
    }

    stop(){
        this.vx = 0;
    }

    jump(){
        if(this.onGround){
            this.vy = -850;
            this.onGround = false;
        }
    }

    attack(){
        if(this.cooldown <= 0){
            this.attacking = true;
            this.attackTime = 0.25;
            this.cooldown = 0.6;
        }
    }

    draw(){

        const bodyY = this.y - this.height;

        // corps
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, bodyY, this.width, this.height);

        // tête
        ctx.fillStyle = "#ffe0b2";
        ctx.fillRect(this.x+10, bodyY-25, 25, 25);

        // yeux
        ctx.fillStyle = "#000";
        ctx.fillRect(this.x+16, bodyY-15, 4,4);
        ctx.fillRect(this.x+28, bodyY-15, 4,4);

        // bouche
        ctx.fillRect(this.x+20, bodyY-5, 10,2);

        // bras
        ctx.fillStyle = this.color;
        ctx.fillRect(
            this.direction === 1 ? this.x+this.width-5 : this.x-5,
            bodyY+10,
            10,
            20
        );

        // épée
        ctx.strokeStyle="#ddd";
        ctx.lineWidth=4;

        if(!this.attacking){
            ctx.beginPath();
            ctx.moveTo(this.x + this.width/2, bodyY-30);
            ctx.lineTo(this.x + this.width/2, bodyY+10);
            ctx.stroke();
        }else{
            const progress = 1 - (this.attackTime/0.25);
            ctx.beginPath();
            ctx.moveTo(this.x + this.width/2, bodyY-30);
            ctx.lineTo(
                this.x + this.width/2 + this.direction*40*progress,
                bodyY+20
            );
            ctx.stroke();
        }
    }

    getAttackBox(){
        if(!this.attacking) return null;

        return {
            x: this.direction === 1 ? this.x+this.width : this.x-40,
            y: this.y-50,
            w: 40,
            h: 50
        };
    }

    getBody(){
        return {
            x:this.x,
            y:this.y-this.height-25,
            w:this.width,
            h:this.height+25
        };
    }
}

const player = new Fighter(150,"#ffffff");
const enemy = new Fighter(700,"#ff4d4d",true);

let keys = {};
let lastTime = 0;

document.addEventListener("keydown",e=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === "e") player.attack();
});

document.addEventListener("keyup",e=>{
    keys[e.key.toLowerCase()] = false;
});

function rect(a,b){
    return a.x < b.x+b.w &&
           a.x+a.w > b.x &&
           a.y < b.y+b.h &&
           a.y+a.h > b.y;
}

function handleInput(){
    player.stop();
    if(keys["q"]) player.move(-1);
    if(keys["d"]) player.move(1);
    if(keys["z"]) player.jump();
}

function enemyAI(){
    const dist = enemy.x - player.x;

    if(Math.abs(dist) > 80){
        enemy.move(dist > 0 ? -1 : 1);
    }else{
        enemy.stop();
        if(Math.random() < 0.02){
            enemy.attack();
        }
    }
}

function combat(){

    const pBox = player.getAttackBox();
    const eBody = enemy.getBody();

    if(pBox && rect(pBox,eBody)){
        enemy.health -= 15;
        enemy.knockback = player.direction * 6;
    }

    const eBox = enemy.getAttackBox();
    const pBody = player.getBody();

    if(eBox && rect(eBox,pBody)){
        player.health -= 10;
        player.knockback = enemy.direction * 6;
    }

    if(enemy.health <= 0){
        playerScore++;
        nextRound();
    }

    if(player.health <= 0){
        enemyScore++;
        nextRound();
    }
}

function nextRound(){
    if(playerScore === 3){
        alert("Victoire !");
        window.location.href="dashboard.html";
        return;
    }
    if(enemyScore === 3){
        alert("Défaite...");
        window.location.href="dashboard.html";
        return;
    }
    player.reset();
    enemy.reset();
}

function drawArena(){

    ctx.fillStyle="#87c9ff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="#6bbf59";
    ctx.fillRect(0,FLOOR,canvas.width,40);

    ctx.fillStyle="#8d6e63";
    platforms.forEach(p=>{
        ctx.fillRect(p.x,p.y,p.w,p.h);
    });

    ctx.fillStyle="#000";
    ctx.fillRect(50,30,300,20);
    ctx.fillRect(550,30,300,20);

    ctx.fillStyle="#4caf50";
    ctx.fillRect(50,30,300*(player.health/player.maxHealth),20);
    ctx.fillRect(550,30,300*(enemy.health/enemy.maxHealth),20);

    ctx.fillStyle="#000";
    ctx.font="20px monospace";
    ctx.fillText(playerScore + " - " + enemyScore,420,45);
}

function loop(timestamp){

    const dt = (timestamp - lastTime)/1000;
    lastTime = timestamp;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawArena();

    handleInput();
    enemyAI();

    player.update(dt,enemy);
    enemy.update(dt,player);

    combat();

    player.draw();
    enemy.draw();

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>
